

# 1. redo log、binlog的区别和作用







# 4. 索引

## 索引常见的模型

- hash表： 等值查询快，范围查询慢
- 数组： 查询快，范围查询也快，就是更新要移动，适合不变动的数据
- 搜索树： 二叉树层级太高，一般是N叉树。 N取决于数据块的大小


**多叉树**

你可以想象一下： 一棵 100 万节点的平衡二叉树，树高20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘**随机读**一个数据块需要 **10 ms** 左右的**寻址时间**。 
>也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。


以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200。这棵树高是 4 的时候，就可以存 1200 的 3 次方个值，这已经 17 亿了。

考虑到**树根的数据块总是在内存中**的，一个 10 亿行的表上一个整数字段的索引，查找一个值**最多只需要访问 3 次磁盘**。

其实，**树的第二层也有很大概率在内存**中，那么访问磁盘的平均次数就更少了。


N 叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。跳表、LSM 树等数据结构也被用于引擎设计中，比如redis就用的跳表。


你心里要有个概念，数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。

## Innodb索引模型

根据叶子节点的内容，索引类型分为主键索引和非主键索引。

- 主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。
- 非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。


**基于主键索引和普通索引的查询有什么区别？**

- 基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。


## 索引维护

B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。
>(当前数据页：300-500-600)
- 如果插入新的行 ID 值为 700，则只需要在 R5(600) 的记录后面插入一个新记录。
- 如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。
- 如果当前数据页已经满了，根据B+树算法，需要申请一个新的数据页，然后挪动部分数据过去。 这个过程成为**页分裂**。 性能会受到影响，同时空间利用率也降低。 
- 相应的也有**页合并**： 由于删除了数据，利用率很低后，需要将数据页做合并。


**哪些场景下应该使用自增主键，而哪些场景下不应该？**

- 自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： NOT NULL PRIMARY KEY AUTO_INCREMENT。插入新记录的时候可以不指定 ID 的值，系统会获取当前 ID 最大值加 1 作为下一条记录的 ID 值。
- **自增主键好处**-性能好： 自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
- **业务逻辑主键坏处**
  - 性能差：业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。
  - 存储空间：**主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。**
    >假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，如果用身份证号做主键，那么每个二级索引的叶子节点（每个非主键索引的叶子节点上都是主键的值）占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。
- 适合用业务字段直接做主键而不是自增主键的场景：
  - 只有一个索引，那就用这个索引字段作为主键
  - 该索引必须是唯一索引。



# 5. 锁

## 全局锁

全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。


全局锁的典型使用场景是，做全库逻辑备份。也就是把整库每个表都 select 出来存成文本。在备份过程中整个库完全处于**只读状态**。


但是让整库都只读，听上去就很危险：如果你在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；如果你在从库上备份，那么备份期间从库不能执行主库同步过来的 binlog，会导致主从延迟。