# 异常那点事
[TOC]

# 异常规约
1. 不要把一大段代码定义在一个try-catch块内，非常不利于定位问题。
2. 区分清楚稳定代码和非稳定代码。`int a = 1;`这种就是稳定代码，无论如何都不会出错。 
3. 异常捕获非稳定代码，要区分异常类型做相应的处理。
4. 谁来处理？ throw是方法内部抛出具体异常类对象的关键字； throws是用在方法signature上的，表示方法调用者可以通过此方法声明向上抛出这种异常对象。
5. 如果异常在当前方法的处理能力范围之内且没必要对外透出，就可以直接捕获处理，不用向上抛出。 否则就向上抛出。
6. 无论采用哪种方式处理异常，都**严禁捕获异常后什么都不做或打印一行日志了事**。 要根据业务做一些定制处理，比如重试、回滚，如果是向上抛出，需要在异常对象中添加上下文参数、局部变量、运行环境等信息，有利于排查问题。


# 异常分类

1. 所有异常都是Throwable的子类，分为：
   - Error致命异常：系统发生了不可控错误，针对此类错误，程序无法处理，需要人工介入。例如：StackOverflowError、OutOfMemoryError
   - Exception 非致命异常：分为
     - checked异常-受检异常：需要在代码中**显示处理**的异常，否则会**编译出错**
        >如果能自行处理，则可以在当前方法捕获异常；如果无法处理，就继续向上抛出。例如：**SQLException**、**ClassNotFoundException**
        - 无能为力、引起注意型： 程序无法处理，比如字段超长导致的SQLException，重试多次也没啥用，一般处理做法是完整地保存异常现场，供工程师介入解决。
        - 力所能及、坦然处理型： 如未授权异常，程序可以跳转到权限申请页面。
     - **unchecked异常**-非受检异常：**运行时异常**，继承自`RuntimeException`，不需要程序进行显示的捕获和处理。
       - 可预测异常（Predicted Exception）：IndexOutBoundsException、NullPointerException等，基于待代码的性能和稳定性要求，这种异常就不应该被产出或抛出，应该提前做好边界检查、空指针判断等处理，提前避免这种异常。 因为显示声明或者捕获此类异常会对程序的 **可读性和运行效率**产生很大影响。
       - 需捕获异常（Caution Exception）：比如Dubbo框架进行RPC调用产生的**远程服务超时异常**，需要客户端进行显示捕获，不能因为服务端异常导致客户端不可用，一般处理方案有**重试或者降级处理**。
       - 可透出异常（Ignored Exception）：框架或者系统产生且会自行处理的异常，不需要程序关心。比如404或者Spring框架抛出的NoSuchRequestHandlingMethodException异常。

# try-catch-finally 处理异常三部曲

- try 不能单独出现，可以搭配catch、finally中的一个或者两个。
- try代码块：监视代码执行过程，一旦出现异常，就会跳转到catch，如果没有异常，就会跳转到finally（如果有的话）。
- catch代码块： 对异常处理还是向上抛出，打印现场都是在这里执行。
- finally代码块： 如果有必定会执行，即使发生了OutOfMemoryError异常，通常用作**处理善后清理工作：清理资源、释放连接、关闭管道流等**。 finally代码块中处理善后工作如果也有异常，也需要try-catch捕获。
- finally没执行有三种可能：
  - 没有进入try代码块
  - 进入try了，但是出现了死循环或死锁状态
  - 进入try了，但是执行了System.exit()操作
- finally实在return表达式运行后执行的，此时已经将要return的结果暂存了起来，执行完finally就会将暂存的结果返回，所以finally对该结果处理是没有用的。 但是finally去return就比较复杂了，吃饱了撑着才会这么干吧。首先声明，finally主要用于善后，释放资源连接关闭流等操作的，当然学习这个主要是为了**避免出错**。

# 异常处理
## 异常的抛和接
1. 对外提供的开放接口：使用错误码；
2. 公司内部跨应用远程服务调用：使用Result对象封装错误码、错误描述信息；
3. 应用内部：直接抛出异常对象。


# 日志
记录系统日志的三大原因：
1. 记录操作轨迹
2. 监控系统运行状况
3. 回溯系统故障

## 日志规范

1. 日志命名：推荐的日志文件命名方式为 appName_logType logName.log。 其中 ， logType 为 日志类型，推荐分类有 stats、 monitor、 visit 等 ， logName 为日志描述。这种命名的 好处是: 通过文件名就可以知道曰志文件属于什么应用，什么类型，什么目的，也有利 于归类查找。例如， mppserver 应用中单独监控时区转换异常的日志文件名定义为
`mppserver_monitor_timeZoneConvert.log`。

2. 日志保存多久？代码规约推荐曰志文件**至少保存15天**，可以根据日志文件的重要程度、 文件大小及磁盘空间再自行延长保存时间。
3. 生产环境禁止输出 DEBUG 曰志旦有选择地输出 INFO日志。 
4. ERROR 级别只记录系统逻辑错误、异常或者违反重要的业务规则，其他错误都可以归为 WARN 级别。用户输入参数错误，这种WARN记录下，方便用户咨询时能还原现场就行。 如果输入ERROR就需要人工介入，显然是不合理的。
5. 确保记录内容完整： 异常堆栈e一定要输出。 输出对象实例时，要确保实例类重写了toString方法，不然只是输出对象的hashCode值，没有实际意义。

记录日志时要考虑三个问题：
 - 日志是否有人看
 - 看到这条日志能做什么
 - 能不能提升问题排查效率。

## 日志框架
log4j、logback、jdk-logging、slf4j、commons-logging等，一般可分为三大部分：
- 日志门面
- 日志适配器
- 日志库



