# Zookeeper入门学习

# 它是什么？
Zookeeper（**动物园管理员**，hadoop中的大多是动物名字）是一个开放源码的分布式服务协调组件，是Google Chubby的开源实现。是一个高性能的分布式数据一致性解决方案。他将那些复杂的、容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并提供一系列简单易用的接口给用户使用。

## 功能特性
- **数据存储**
  - zookeeper提供了类似Linux文件系统一样的数据结构。每一个节点对应一个Znode节点，每一个Znode节点都可以存储1MB（默认）的数据。
  - 客户端对zk的操作就是对Znode节点的操作。
    - Znode:包含ACL权限控制、修改/访问时间、最后一次操作的事务Id(zxid)等等
    * 说有数据存储在内存中，在内存中维护这么一颗树。
    * 每次对Znode节点修改都是**保证顺序**和原子性的操作。**写**操作是**原子性**操作。
  * 每一个Znode节点又根据节点的生命周期与类型分为4种节点。
    * 持久节点（带不带顺序编号）、临时节点（带不带顺序编号）
    * 生命周期：当客户端会话结束的时候，是否清理掉这个会话创建的节点。持久-不清理，临时-清理。
    * 类型：每一个会话，创建单独的节点（例子：正常节点：rudytan,顺序编号节点：rudytan001,rudytan002等等）
* **监听机制**
  * zookeeper除了提供对Znode节点的处理能力，还提供了对节点的变更进行监听通知的能力。
  * 监听机制的步骤如下：
    * 任何session(session1,session2)都可以对自己感兴趣的znode监听。
    * 当znode通过session1对节点进行了修改。
    * session1,session2都会收到znode的变更事件通知。
  * 节点常见的事件通知有：
    * session建立成功事件
    * 节点添加
    * 节点删除
    * 节点变更
    * 子节点列表变化
  >**特别注意**:一次监听事件，只会被触发一次，如果想要监听到znode的第二次变更，需要重新注册监听。

## 应用场景        
- **注册中心**
  - 依赖于**临时节点**
    * 消费者启动的时候，会先去注册中心中全量拉取服务的注册列表。
    * 当某个服务节点有变化的时候，通过监听机制做数据更新。
    * zookeeper挂了，不影响消费者的服务调用。

**注册中心对比**: `Eureka` VS `Zookeeper`
  - Eureka中的节点每一个节点对等。Eureka是个AP系统，而不是zk的CP系统。
  - 在注册中心的应用场景下，相对于与强数据一致性，**更加关心可用性**。

- **分布式锁**
  - 依赖于**临时顺序节点**
  * 判断当前client的**顺序号是否是最小**的，如果是获取到锁。
  * 没有获取到锁的节点**监听最小节点的删除事件**（比如lock_key_001）
  * 锁释放，最小节点删除，剩余节点重新开始获取锁。
  * 重复步骤二到四。

**分布式锁对比**： `redis` vs `数据库` vs `zk`
  - 从`理解`的难易程度角度（从低到高）
      > 数据库 > 缓存（Redis） > Zookeepe
  - 从实现的`复杂性`角度（从低到高）
      > Zookeeper >= 缓存（Redis） > 数据库
  - 从`性能`角度（从高到低）
      > 缓存（Redis） > Zookeeper >= 数据库
  - 从`可靠性`角度（从高到低）
      > Zookeeper > 缓存（Redis） > 数据库

- **集群管理与master选举**
  * 依赖于临时节点
  * zookeeper保证无法重复创建一个已存在的数据节点，创建成功的client为master。
  * 非master，在已经创建的节点上注册节点删除事件监听。
  * 当master挂掉后，其他集群节点收到节点删除事件，进行重新选举
  * 重复步骤二到四

>有人说，zookeeper可以做分布式配置中心、分布式消息队列，看到这里的小伙伴们，你们觉得合适么？

## 高性能高可用强一致性保障


- **高性能-分布式集群**：
    >高性能，我们通常想到的是通过集群部署来突破单机的性能瓶颈。对于zk来说，就是通过部署多个节点共同对外提供服务，来提供读的高性能。
  * Master/Slave模式。
  * 在zookeeper中部署多台节点对外提供服务，客户端可以连接到任意一个节点。
  * 每个节点的数据都是一样的。
  * 节点根据角色分为Leader节点与Learner节点（包括Follower节点与Observer节点）。
  * 集群中，只有一个Leader节点，完成所有的写请求处理。
  * 每次写请求都会生成一个全局的唯一的64位整型的事务ID(可以理解为全局的数据的版本号)。
  * Learner节点可以有很多，每个Leaner可以独自处理读请求，转写请求到Leader节点。
  * 当Leader节点挂掉后，会从Follower节点中通过选举方式选出一个Leader提供对外服务。
  * Follower节点与Observer节点区别在于不参与选举和提议的事务过半处理。
  * 集群通常是按照奇数个节点进行部署（偶数对容灾没啥影响，浪费机器）。

- **数据一致性**（zab协议-原子广播协议）


# 参考资料
- [一篇文章带你深入理解Zookeeper](https://mp.weixin.qq.com/s/38JLeXS54Ji-ozLRQpv0JQ)