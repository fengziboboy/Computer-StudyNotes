
# 《Go语言核心36讲》

## 学习路线

## 模块一：Go语言基础知识

### 工作区与GOPATH
- **GOROOT**：Go语言安装根目录的路径，也就是Go语言的安装路径。
- **GOPATH**：若干工作目录的路径（可以是多个目录路径）。是我们自己定义的工作空间。
- **GOBIN**：GO程序生成的可执行文件的路径。

问题：
1. Go语言源码的组织方式是怎样的？
   - 以代码包为基本组织单元。跟java一样，多级目录就是子包。
   - 代码包一般会与源码文件所在目录同名（java好像是必须同名）。 如果不同名，在构建、安装过程中以代码包名称为准。 
   - 而其他代码在使用该包中的实体时，引用的路径为**包路径？**（还是目录路径）
  	>一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相 对路径
   - 每个包可以包含任意个.go的源码文件。
   - Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为 主线的
2. 你是否了解源码安装后的结果？（只有安装后，Go语言源码才能被我们或者其他代码使用）
3. 你是否理解构建和安装Go程序的过程？

### 命令行源码文件 VS 库源码文件


**库源码文件**是不能被直接运行的源码文件，它仅用于存放程序实体，这些**程序实体**可以被其他代码使用(只要遵从 Go 语言规范的话)。
- 程序实体是变量、常量、函数、结 构体和接口的统称。

**问题**： 怎么把命令源码文件中的代码拆分到其他库源码文件？

### 程序实体那些事儿

## 模块二：Go语言进阶技术

### 7. 数组和切片


### 8. container包中的那些容器
- **List** 实现了一个双向链表(以下简称链表)
- **Element** 则代表了链表中元素的结构。


**可以把自己生成的Element类型值传给链表吗?**


List的四个方法：
- `MoveBefore`方法和`MoveAfter`方法，它们分别用于**把给定的元素移动**到另一个元素的**前面和后面**。
- `MoveToFront`方法和`MoveToBack`方法，分别用于把给定的元素移动到链表的**最前端和最后端**。
   - “给定的元素”都是*Element类型的
   - *Element**类型**是Element类型的**指针类型**
   - *Element的**值**就是元素的**指针**。
 - `Front`和`Back`方法分别用于**获取**链表中最前端和最后端的元素。
 - `InsertBefore`和`InsertAfter`方法分别用于在**指定的元素**之前和之后插入新元素。
 - `PushFront`和`PushBack`方法则分别用于在链表的**最**前端和最后端**插入**新元素。
```go
//move
func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveToFront(e *Element)
//get
func (l *List) Front() *Element
//insert
func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) PushFront(v interface{}) *Element

```
- 函数名MoveBefore前面的`(l *List)`是啥东西？
- 这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。


**开箱即用**
- List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有 特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予 各自类型的零值。
  - 零值：只做声明还未初始化的变量被给予了默认值。 比如，
    - 经过语句var s []int声明的变量s的值将会是一个 []int类型的、值为nil的切片。
    - 经过语句var l list.List声明的变量l的值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容
- Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包(或者说程序库)时，我们推荐遵循的最佳实践之一。
- List如何做到开箱即用？
  - 关键在于它的“延迟初始化”机制，把初始化操作延后，仅在实际需要的时候才进行。
  - 这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方 法，一旦发现链表的长度为0, 直接返回nil就好了。
  - 链表的PushFront方法、PushBack方法、PushBackList方法以及 PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始 化。
  - List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优 缺点，使得链表可以开箱即用，并且在性能上可以达到最优。
- Element类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所 属链表的指针值。
- 另外还有一个名叫Value的公开的字段，该字段的作用就是持有元素的实 际值，它是interface{}类型的。


**问题 2:Ring与List的区别在哪儿?**
- ring实现的是一个循环列表，俗称的环。 
- 其实List在内部就是一个循环列表，只是它的根元素永远不会有任何的元素值，该元素的存在就是为了连接这个循环链表的首尾两端。
- 区别？
  - Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。
  - 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类 型的值则代表了一个完整的链表。
  - 创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个 List值来说却不能这样做(也没有必要这样做)，ring是固定大小的。
  - 仅通过`var r ring.Ring`语句声明的r将会是一个长度为1的循环链表，而List类型的 零值则是一个长度为0的链表。
  - Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的


切片这种动态扩展的特性，会出现复制很多个？啥时候回收？很浪费呀！

- 在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配的量以及元素复制的次数可能就很可观了，这肯定会对程序的性能产生负面的影响。
- 尤其是当我们没有一个合理、有效的”缩容“策略的时候，旧的底层数组无法被回收，新的底层数组中也会有大量无用的元素槽位。
- 过度的内存浪费不但会降低程序的性能，还可能会使内存溢出并导致程序崩溃。


由此可见，正确地使用切片是多么的重要。


**典型使用场景**
- list的一个典型应用场景是构造FIFO队列; 作为queue和stack的基础数据结构
- ring的一个典型应用场景是构造定长环回队列， 比如网页上的轮播;
- heap的一个典型应用场景是构造优先级队列。heap可以用来排序


### 9. 字典（map）的操作和约束
其实是一个哈希表的特定实现，在这个实现中，键的类型是受限的，而元素却可以是任意类型的。
- 如何通过键值去定位映射的value元素
  - 哈希表会先用哈希函数(hash function)把键值转换为哈希值。**哈希值通常是一个无符号的整数**。
  - 一个哈希表会持有一定数量的桶(bucket)，我们也可以叫它哈希桶，这些哈希 桶会均匀地储存其所属哈希表收纳的键 - 元素对。
  - 哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。
  - 由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素 值。


**字典的键类型不能是哪些类型?**
>Go 语言 字典的键类型**不可以是**函数类型、字典类型和切片类型。
- 键类型的值**必须要支持判等**操作。而函数类型、字典类型和切片类型的值并不支持判等操作
  - 因为要去根据哈希值寻找值在哪个桶去判断等，如果哈希值相等，还需要判断值是否相等，这里就要求值必须可以比较相等了。因为会存在哈希碰撞。
- 如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型
```go
//变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。
或者说，我通过这样的声明躲过了 Go 语言编译器的检查
var badMap2 = map[interface{}]int{
   "1": 1,
   []]int{2}: 2, // 这里会引发 panic。
    3: 3, 
    }
```


### 10. 通道的基本操作


### 11. 通道的高级用法


### 12. 使用函数的正确姿势


### 13. 结构体及其方法使用法门


### 14. 接口类型的合理利用


### 15. 关于指针的优先操作


### 16. go语句

### 17. if语句、for语句、switch语句


### 18. 错误处理


### 19. panic函数、recover函数以及defer语句

## 模块三：Go语言实战应用


## 尾声和思考