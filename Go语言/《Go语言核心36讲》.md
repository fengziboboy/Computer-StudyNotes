
# 《Go语言核心36讲》

## 学习路线

## 模块一：Go语言基础知识

### 工作区与GOPATH
- **GOROOT**：Go语言安装根目录的路径，也就是Go语言的安装路径。
- **GOPATH**：若干工作目录的路径（可以是多个目录路径）。是我们自己定义的工作空间。
- **GOBIN**：GO程序生成的可执行文件的路径。

问题：
1. Go语言源码的组织方式是怎样的？
   - 以代码包为基本组织单元。跟java一样，多级目录就是子包。
   - 代码包一般会与源码文件所在目录同名（java好像是必须同名）。 如果不同名，在构建、安装过程中以代码包名称为准。 
   - 而其他代码在使用该包中的实体时，引用的路径为**包路径？**（还是目录路径）
  	>一个代码包的导入路径实际上就是从 src 子目录，到该包的实际存储位置的相 对路径
   - 每个包可以包含任意个.go的源码文件。
   - Go 语言源码的组织方式就是以环境变量 GOPATH、工作区、src 目录和代码包为 主线的
2. 你是否了解源码安装后的结果？（只有安装后，Go语言源码才能被我们或者其他代码使用）
3. 你是否理解构建和安装Go程序的过程？

### 命令行源码文件 VS 库源码文件


**库源码文件**是不能被直接运行的源码文件，它仅用于存放程序实体，这些**程序实体**可以被其他代码使用(只要遵从 Go 语言规范的话)。
- 程序实体是变量、常量、函数、结 构体和接口的统称。

**问题**： 怎么把命令源码文件中的代码拆分到其他库源码文件？

### 程序实体那些事儿

## 模块二：Go语言进阶技术

### 7. 数组和切片


### 8. container包中的那些容器
- **List** 实现了一个双向链表(以下简称链表)
- **Element** 则代表了链表中元素的结构。


**可以把自己生成的Element类型值传给链表吗?**


List的四个方法：
- `MoveBefore`方法和`MoveAfter`方法，它们分别用于**把给定的元素移动**到另一个元素的**前面和后面**。
- `MoveToFront`方法和`MoveToBack`方法，分别用于把给定的元素移动到链表的**最前端和最后端**。
   - “给定的元素”都是*Element类型的
   - *Element**类型**是Element类型的**指针类型**
   - *Element的**值**就是元素的**指针**。
 - `Front`和`Back`方法分别用于**获取**链表中最前端和最后端的元素。
 - `InsertBefore`和`InsertAfter`方法分别用于在**指定的元素**之前和之后插入新元素。
 - `PushFront`和`PushBack`方法则分别用于在链表的**最**前端和最后端**插入**新元素。
```go
//move
func (l *List) MoveBefore(e, mark *Element)
func (l *List) MoveToFront(e *Element)
//get
func (l *List) Front() *Element
//insert
func (l *List) InsertBefore(v interface{}, mark *Element) *Element
func (l *List) PushFront(v interface{}) *Element

```
- 函数名MoveBefore前面的`(l *List)`是啥东西？
- 这些方法都会把一个Element值的指针作为结果返回，它们就是链表留给我们的安全“接口”。


**开箱即用**
- List和Element都是结构体类型。结构体类型有一个特点，那就是它们的零值都会是拥有 特定结构，但是没有任何定制化内容的值，相当于一个空壳。值中的字段也都会被分别赋予 各自类型的零值。
  - 零值：只做声明还未初始化的变量被给予了默认值。 比如，
    - 经过语句var s []int声明的变量s的值将会是一个 []int类型的、值为nil的切片。
    - 经过语句var l list.List声明的变量l的值将会是一个长度为0的链表。这个链表持有的根元素也将会是一个空壳，其中只会包含缺省的内容
- Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包(或者说程序库)时，我们推荐遵循的最佳实践之一。
- List如何做到开箱即用？
  - 关键在于它的“延迟初始化”机制，把初始化操作延后，仅在实际需要的时候才进行。
  - 这里的链表实现中，一些方法是无需对是否初始化做判断的。比如Front方法和Back方 法，一旦发现链表的长度为0, 直接返回nil就好了。
  - 链表的PushFront方法、PushBack方法、PushBackList方法以及 PushFrontList方法总会先判断链表的状态，并在必要时进行初始化，这就是延迟初始 化。
  - List利用了自身以及Element在结构上的特点，巧妙地平衡了延迟初始化的优 缺点，使得链表可以开箱即用，并且在性能上可以达到最优。
- Element类型包含了几个包级私有的字段，分别用于存储前一个元素、后一个元素以及所 属链表的指针值。
- 另外还有一个名叫Value的公开的字段，该字段的作用就是持有元素的实 际值，它是interface{}类型的。


**问题 2:Ring与List的区别在哪儿?**
- ring实现的是一个循环列表，俗称的环。 
- 其实List在内部就是一个循环列表，只是它的根元素永远不会有任何的元素值，该元素的存在就是为了连接这个循环链表的首尾两端。
- 区别？
  - Ring类型的数据结构仅由它自身即可代表，而List类型则需要由它以及Element类型联合表示。
  - 一个Ring类型的值严格来讲，只代表了其所属的循环链表中的一个元素，而一个List类 型的值则代表了一个完整的链表。
  - 创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个 List值来说却不能这样做(也没有必要这样做)，ring是固定大小的。
  - 仅通过`var r ring.Ring`语句声明的r将会是一个长度为1的循环链表，而List类型的 零值则是一个长度为0的链表。
  - Ring值的Len方法的算法复杂度是 O(N) 的，而List值的Len方法的算法复杂度则是 O(1) 的


切片这种动态扩展的特性，会出现复制很多个？啥时候回收？很浪费呀！

- 在切片被频繁“扩容”的情况下，新的底层数组会不断产生，这时内存分配的量以及元素复制的次数可能就很可观了，这肯定会对程序的性能产生负面的影响。
- 尤其是当我们没有一个合理、有效的”缩容“策略的时候，旧的底层数组无法被回收，新的底层数组中也会有大量无用的元素槽位。
- 过度的内存浪费不但会降低程序的性能，还可能会使内存溢出并导致程序崩溃。


由此可见，正确地使用切片是多么的重要。


**典型使用场景**
- list的一个典型应用场景是构造FIFO队列; 作为queue和stack的基础数据结构
- ring的一个典型应用场景是构造定长环回队列， 比如网页上的轮播;
- heap的一个典型应用场景是构造优先级队列。heap可以用来排序


### 9. 字典（map）的操作和约束
**创建**：
- 直接声明“var m map[int]string”的形式声明出来的m为nil; 
- 采用make函数创建的map不为nil，可以进行添加键值对的操作。


其实是一个哈希表的特定实现，在这个实现中，**键的类型是受限的，而元素却可以是任意类型的**。
- 如何通过键值去定位映射的value元素
  - 哈希表会先用哈希函数(hash function)把键值转换为哈希值。**哈希值通常是一个无符号的整数**。
  - 一个哈希表会持有一定数量的桶(bucket)，我们也可以叫它哈希桶，这些哈希 桶会均匀地储存其所属哈希表收纳的键 - 元素对。
  - 哈希表会先用这个键哈希值的低几位去定位到一个哈希桶，然后再去这个哈希桶中，查找这个键。
  - 由于键 - 元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素 值。


字典不会单独存储键的值，只会存储键的哈希值，而查找的时候如果哈希值匹配上，还需要去比较键值，防止哈希碰撞。这里的键值是放在哪里？如何拿到的？
>哈希桶里的结构是，“键的哈希值-内部结构”对的集合，这个内部结构的结构是“键1 元素1 键2 元素2 键3 元素3”，是一块连续的内存。在通过键的哈希值定位找到哈希桶和那 个“键的哈希值-内部结构”对之后，就开始在这个内部结构里找有没有这个键。

**字典的键类型不能是哪些类型?**
>Go 语言 字典的**键**类型**不**可以是**函数类型、字典类型和切片类型**。
- 键类型的值**必须要支持判等**操作。而函数类型、字典类型和切片类型的值并不支持判等操作
  - 因为要去根据哈希值寻找值在哪个桶去判断等，如果哈希值相等，还需要判断值是否相等，这里就要求值必须可以比较相等了。因为会存在哈希碰撞。
- 如果键的类型是接口类型的，那么键值的实际类型也不能是上述三种类型
```go
//变量badMap2的类型是键类型为interface{}、值类型为int的字典类型。这样声明并不会引起什么错误。
或者说，我通过这样的声明躲过了 Go 语言编译器的检查
var badMap2 = map[interface{}]int{
   "1": 1,
   []]int{2}: 2, // 这里会引发 panic。
    3: 3, 
    }
```
- 当我们运行这段代码的时候，Go 语言的运行时(runtime)系统就会发现这里的问 题，它会抛出一个 panic。
- 我们越晚发现问题，修正问题的成本就会越高，所以**最好不要把字典的键类型设定为任何接口类型**。
- 如果键的类型是数组类型，那么还要确保该类型的元素类型不是函数类型、字典
类型或切片类型。


**应该优先考虑哪些类型作为字典的键类型？**
- 从性能考虑：**求哈希和判等操作的速度越快**，对应的类型就**越适合**作为键类型
  - 以求哈希的操作为例，宽**度越小**的类型**速度通常越快**。
    - 类型的**宽度**是指它的单个值需要占用的字节数。bool、int8和uint8类型的一个值 需要占用的字节数都是1
    - 对于布尔类型、整数类型、浮点数类型、复数类型和指针类型来说都是如此。
    - 对于字符串类型，由于它的宽度是不定的，所以要看它的值的具体长度，长度越短求哈 希越快。
    - 对数组类型的值求哈希实际上是依次求得它的每个元素的哈希值并进行合并，所以速度就取决于它的元素类型以及它的长度。 修改数组的值就是不一样的hash值了，所以不推荐使用
    - 对结构体类型的值求哈希实际上就是对它的所有字段值求哈希并进行合并，所以关键在于它的各个字段的类型以及字段的数量。可以控制其中各字段的访问权限的话，就可以阻止外界修改它了
    - 而对于接口类型，具体的哈希算法，则由值的实际类型决定。把接口类型作为字典的键类型**最危险**。
  - 优先选用数值类型和指针类型，通常情况下类型的宽度越小越好。如果非要选择字符串类型的话，最好对键值的长度进行额外的约束。


**在值为nil的字典上执行读操作会成功吗，那写操作呢?**
- 在一个值为nil的字典上，添加键-元素会引起运行时抛出一个panic，其他任何操作都不会引起错误。
  - 既然无法添加键值对，那是不是就无用？ **可以对m直接用索引表达式添加**


其他：
- map不是并发安全的， 判断一个操作 是否是原子的可以使用 `go run race` 命令做数据的竞争检测

### 10. 通道的基本操作
>Don’t communicate by sharing memory; share memory by communicating. (不要通过共享内存来通信，而应该通过通信来共享内存。)  ---Go 语言的主要创造者之一的 Rob Pike 的至理名言

通道类型是后半句话的完美实现，我们可以利用通道在多个 goroutine 之间传递数据。


**基础知识**：
- **通道类型的值**本身就是**并发安全**的，这也是 Go 语言自带的、唯一一个可以满足并发安全性 的类型。
- 用内建函数make声明一个通道类型变量，第一个参数用代表**通道具体类型**的类型字面量。 同时要确认该通道的**元素类型**，决定这个通道传递声明类型数据。
  - `chan int`，其中chan表示通道类型的关键字， int是该通道的元素类型。
  - make函数除了必须接收这样的类型字面量作为参数，还可以接收一个可选的int类型的参数作为容量。
  - 当容量为0时，我们可以称通道为非缓冲通道，反之就是缓存通道。
- 一个通道相当于一个**先进先出**(FIFO)的队列。
  - 也就是说，通道中的各个元素值都是严格地**按照发送的顺序排列**的，先被发送通道的元素值一定会先被接收。
- 元素值的发送和接收都需要用到**操作符<-**。
  - 我们也可以叫它**接送操作符**。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。
- 从通道接收元素值的时候，同样要用接送操作符<-，只不过，这时需要把它写 在变量名的左边，用于表达“要从该通道接收一个元素值”的语义。
  - 比如`<-ch1`，这也可以被叫做**接收表达式**。
  - 如果我们需要把如此得来的元素值存起来，那么在接收表达式的左边就需要依次添加赋值符 号(=或:=)和用于存值的变量的名字。
```go
func main() {
        ch1 := make(chan int, 3)
        ch1 <- 2
        ch1 <- 1
        ch1 <- 3
        //将最先进入ch1 的元素2接收来并存入变量elem1
        elem1 := <-ch1
        fmt.Printf("The first element received from channel ch1: %v\n",elem1)
```


**对通道的发送和接收操作都有哪些基本特性？**
- 对于同一个通道，发送操作之间和接收操作之间是互斥的。 
  - 发送和接收操作之间呢？
  - 对于通道中的**同一个元素值**来说，**发送操作和接收操作之间也是互斥的**。
- 发送操作和接收操作对元素值的处理是原子性的不可分割。
  - 元素值从外界进入通道时会被复制，也就是进入通道的是其副本。
  - 移动操作分两步： 先生存通道值这个元素值的副本，准备给到接收方，接着删除通道中这个元素值。
  - 接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况。
- 发送操作完成之前会被阻塞，接收操作也是如此。
  - 接收操作通常包含了“复制通道内的元素值”“放置副本到接收方”“删掉原值”三个步骤。
  - 在所有这些步骤完全完成之前，发起该操作的代码也会一直阻塞，直到该代码所在的 goroutine 收到了运行时系统的通知并重新获得运行机会为止。
  - 如此阻塞代码其实就是为了实现操作的互斥和元素值的完 整。
- 长度代表通道当前包含的元素个数，容量就是初始化时你设置的那个数。
- 通道底层存储数据的是环形链表。


**发送操作和接收操作在什么时候可能被长时间的阻塞?**
- 缓存通道： 
  - 满了-》所有发送操作会被阻塞，知道元素被接收走，会优先通知最早等待、那个发送操作所在的goroutine。
  - 空了-》接收操作被阻塞。。。
- 非缓存通道：无论是发送操作还是接收操作，一开始执行就会被阻 塞，直到配对的操作也开始执行，才会继续传递。 
  - 就是**同步**的方式传递数据。
  - 数据是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转。**那还会有删除通道中的元素这个操作嘛？**
- 一定不要忘记初始化通道。（用make函数去做初始化）
  - 对于值为nil的通道，无论它具体是什么类型，对它的发送操作和接收操作都会永久地处于阻塞状态。
  - 通道是引用类型。


**发送操作和接收操作在什么时候会引发 panic?**
- 对已关闭的通道进行发送操作，会应发panic
- 试图关闭一个已经关闭的通道。

接收操作是可以感知到通道的关闭的，并能够安全退出。
- 接收表达式的结果会有两个变量，第二个变量类型是bool，为false表示通道已经关闭，并且没有元素可以取了。 
- 如果还有元素可以取，但是通道关闭了，那么接收表达式的第一个结果，仍会是 通道中的某一个元素值，而第二个结果值一定会是true。（这个接收操作是在关闭后做的还是？是在关闭后，**通道关闭后还是可以进行接收操作**？直到其没有元素）
  - 因此，通过接收表达式的第二个结果值，来判断通道是否关闭是可能有延时的。
  - 所以，**千万不要让接收方关闭通道，而是让发送发做这件事。**


### 11. 通道的高级用法
**单项通道**： 只能接收或者只能发送的通道
- 定义（**从操作chan的代码的角度**）：
  - chan<- int 只能发送不能接收。（只能把数据发给chan）
  - <-chan int 只能接收不能发送。
```go
var uselessChan = make(chan<- int, 1)
```


**单项通道有什么应用价值？**
最主要的用途就是约束其他代码的行为。
>一个类型如果想成为一个接口类型的实现类型，那么就必须实现这个接口中定义的所有方法。
- 因此，如果我们在某个方法的定义中使用了单向通道类型，那么就相当于在对它的所有实现做出约束。
- 在**函数声明的结果列表中使用单向通道**: 函数getIntChan会返回一个<-chan int类型的通道，这就意味着得到该通道的程序， 只能从通道中接收元素值。这实际上就是对函数调用方的一种约束了。
```go
func getIntChan() <-chan int {
   num := 5
   ch := make(chan int, num)
   for i := 0; i < num; i++ {
      ch <- i
   }
   close(ch)
   return ch
}
```
- 在 Go 语言中还可以声明函数类型，如果我们在函数类型中使用了单向通道，那 么就相等于在约束所有实现了这个函数类型的函数.


顺便看一下调用getIntChan的代码: 
```go
intChan2 := getIntChan()
for elm := range intChan2 {
   fmt.Printf("The element in intChan2: %v\n", elem)
}
```
把调用getIntChan得到的结果值赋给了变量intChan2，然后用for语句循环地取出了 该通道中的所有元素值，并打印出来。

带有range子句的for语句的用法说明：
- 一、这样一条for语句会不断地尝试从intChan2种取出元素值，即使intChan2被关 闭，它也会在取出所有剩余的元素值之后再结束执行。
- 二、当intChan2中没有元素值时，它会被阻塞在有for关键字的那一行，直到有新的元 素值可取。
- 三、假设intChan2的值为nil，那么它会被永远阻塞在有for关键字的那一行。
>这就是带range子句的for语句与通道的联用方式。 Go 语言还有一种专门为了操作 通道而存在的语句:select语句。


**select语句与通道怎样联用，应该注意些什么？**
- select语句只能与通道联用，它一般由若干个分支组成。每次只有一个分支中的代码会被运行。
- 分支分为2种：
  - 候选分支： 总是以 case 开头，后跟一个case表达式和一个冒号，再下一行写需要执行的语句。 类似switch的case
  - 默认分支： default case， 同上。
- 每个case表达式只能包含操作通道的表达式，比如接收表达式。 
  >如果我们需要把接收表达式的结果赋给变量的话，还可以把这里写成**赋值语句或者短变量声明。**
```go
func example1() {
	// 准备好几个通道。
	intChannels := [3]chan int{
		make(chan int, 1),
		make(chan int, 1),
		make(chan int, 1),
	}
	// 随机选择一个通道，并向它发送元素值。
	index := rand.Intn(3)
	fmt.Printf("The index: %d\n", index)
	intChannels[index] <- index
	// 哪一个通道中有可取的元素值，哪个对应的分支就会被执行。
	select {
	case <-intChannels[0]:
		fmt.Println("The first candidate case is selected.")
	case <-intChannels[1]:
		fmt.Println("The second candidate case is selected.")
	case elem := <-intChannels[2]:
		fmt.Printf("The third candidate case is selected, the element is %d.\n", elem)
	default:
		fmt.Println("No candidate case is selected!")
	}
}
```


### 12. 使用函数的正确姿势


### 13. 结构体及其方法使用法门


### 14. 接口类型的合理利用


### 15. 关于指针的优先操作


### 16. go语句

### 17. if语句、for语句、switch语句


### 18. 错误处理


### 19. panic函数、recover函数以及defer语句

## 模块三：Go语言实战应用


## 尾声和思考