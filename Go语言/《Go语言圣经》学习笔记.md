

# 基础部分

## 第一章 总览Go语言能做啥
通过十几个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。

### 入门


- 缺少了必要的包或者导入了不需要的包，程序都无法编译通过。Go语言编译过程没有警告信息，争议特性之一
- 不需要添加分号，除非一行有多填语句。编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析。
  - 行末出现：比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字break、continue、fallthrough或return中的一个、运算符和分隔符++、--、)、]或}中的一个），会自动插入分号分割符。 
  - 以+结尾的话不会被插入分号分隔符，所以 a + b， 可以在 + 号后面换行，不能在加号前面，因为 a后面换行会被插入分号，那编译就报错了。


#### 命令行参数
- **输入源：**自于程序外部：文件、网络连接、其它程序的输出、敲键盘的用户、命令行参数或其它类似输入源。
- **包导入顺序**并不重要；gofmt工具格式化时**按照字母顺序对包名排序**。
- i--给i减1。它们是语句，而不像C系的其它语言那样是表达式。所以j = i++非法，而且++和--都**只能放在变量名后面**，因此--i也非法。


**命令行参数**


- 程序的命令行参数可从os包的Args变量获取；os包外部使用os.Args访问该变量。
- os.Args变量是一个字符串（string）的切片（slice）
- os.Args的第一个元素：os.Args[0]，是命令本身的名字；其它的元素则是程序启动时传给它的参数


- for循环，唯一的循环，多种形式。
```go
for initialization; condition; post {
    // zero or more statements
}
```
  - initialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。
  - condition是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。
  - post语句在循环体执行结束后执行，**之后再次**对condition求值。
- for循环的这三个部分每个都可以省略，如果省略initialization和post，分号也可以省略（相当于 while）：
```go
// a traditional "while" loop
for condition {
    // ...
}
```
- 省略掉condition，变成for{} ，无限循环，可以用 break，return终止。
- for循环的另一种形式，**在某种数据类型的区间（range）上遍历**，如字符串或切片。

```go
// Echo2 prints its command-line arguments.
package main

import (
    "fmt"
    "os"
)

func main() {
    s, sep := "", ""
    for _, arg := range os.Args[1:] {
        s += sep + arg
        sep = " "
    }
    fmt.Println(s)
}
```
  - 每次循环迭代，range产生一对值；索引以及在该索引处的元素值。
  - 这个例子不需要索引，但range的语法要求，要处理元素，必须处理索引
    - 一种思路是把索引赋值给一个临时变量（如temp）然后忽略它的值，但Go语言不允许使用无用的局部变量（local variables）
    - go语言提供了一种解决方案：`空标识符（blank identifier）`，即`_`（也就是下划线）。
      - 空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候
```go
// Echo2 prints its command-line arguments.
package main

import (
	"fmt"
	"os"
	"strconv"
	"strings"
)

func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
	fmt.Println(strings.Join(os.Args[1:], " "))
	fmt.Println("methodName:" + os.Args[0])

	for i, arg := range os.Args[1:] {
		fmt.Println(strconv.FormatInt(int64(i), 10) + ":" + arg)
	}

}
```

#### 查找重复的行


## 第二章 基本实体
元素结构、变量、新类型定义、包和文件、以及作用域等概念


## 第三章 数字、布尔值、字符串和常量
- 并演示了如何显示和处理Unicode字符
- 

## 第四章 复合类型

从简单的数组、字典、切片到动态列表

### 定长数组 array


### 可变数组 slice
- 是否可称为引用类型？ 有说可以叫指针结构的包装，比叫引用类型更严谨。
- 用s[i]访问单个元素，用s[m:n]获取子序列。Go言里也采用左闭右开形式，0 ≤ m ≤ n ≤ len(s)，包含n-m个元素。

#### 难点一： 长度len 和 容量cap
**一个切片的容量总是固定的。**


例子：
```go
s3 := []int{1, 2, 3, 4, 5, 6, 7, 8}
s4 := s3[3:6]
```

s3的长度和容量都是 8
s4的长度/大小是3，**s4的容量是多少？**
- 切片的容量代表了它的底层数组的长度，但这仅限于使用make函数或者切片值字面量初始化切片的情况。
- 更通用的规则是: 一个切片的容量可以被看作是透过这个窗口最多可以看到的底层数组中元素的个数。
  - 而在底层数组不变的情况下，切片代表的**窗口可以向右扩展，直至其底层数组的末尾**。
    - 这里底层数组是最底层，哪怕slicea 从arr而来，sliceb从slicea而来。


#### 为啥要弄这种滑动窗口式的设计

#### slice[2:] 省略掉的是len(slice)
省略掉的：默认第一个序列是0，第二个是数组的长度，即等价于ar[0:len(ar)]


从Go1.2开始slice支持了三个参数的slice：
```go
var array [10]int
sliceA := array[2:4]   //slice的容量是8
sliceB = array[2:4:7]   //这个7是底层数组的位置，表示该切片最多到这个位置。上面这个的容量就是7-2，即5。这样这个产生的新的slice就没办法访问最后的三个元素。
sliceB[2] 会抛异常，超出边界。 长度只有2.
```



#### 扩容：
- 它并不会改变原来的切片，而是会生成一个容量更大的切片，然后将把原有的元素和新元素一并拷贝到新切片中。
  - 拷贝耗费性能嘛？ 原来的切片是否保留？回收啥时候回收？
  - 扩容2倍，当原长度大于或等于1024时，Go 语言将会以原容量的 1.25倍作为新容量的基准(以下新容量基准)


**切片的底层数组什么时候会被替换?**
- 确切地说，一个切片的底层数组永远不会被替换。
- 为什么?虽然在扩容的时候 Go 语言一定会生成新的底层数组，但是它也同时生成了新的切片。
- 没有为切片替换底层数组这一说，扩容是直接换新的切片。。。
- 在无需扩容时，append函数返回的是**指向原底层数组的新切片**，而在需要扩容时，append函数返回的是**指向新底层数组的新切片**。


**知识点**
1. 初始时两个切片引用同一个底层数组，在后续操作中对某个切片的操作超出底层数组的容 量时，这两个切片引用的就不是同一个数组了




### map[keyType]valueType
- map的key，可以是int，可以是string及所有完全定义了==与!=操作的类型



## 第五章 函数、错误处理、panic、recover、有defer语句。


# Go语言特性
>接口、并发、包、测试和反射等语言特性。

Go语言的面向对象机制与一般语言不同。
- 它没有类层次结构，甚至可以说没有类；
- 仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。
- 方法不仅可以定义在结构体上，而且，可以定义在任何用户自定义的类型上；
- 并且，具体类型和抽象类型（接口）之间的关系是隐式的，

>所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。

## 第六章 方法



## 第七章 接口


## 第八章 并发编程（一）基于顺序通信进程（CSP）

使用goroutines和channels处理并发编程

## 第九章 并发编程（二）传统的基于共享变量


## 第十章 包机制和包的组织结构


这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。

## 第十一章 单元测试
Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。


## 第十二章 反射

一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数，展示了反射的强大用法

## 第十三章 底层编程的细节

在必要时，可以使用unsafe包绕过Go语言安全的类型系统。