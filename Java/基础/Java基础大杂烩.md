

# 你对Java平台的理解

## 特点、特性

### 第一印象

>思维深入，且系统化
- Write Once，run anywhere，跨平台。 因为字节码-虚拟机
- 垃圾回收GC，自动内存分配和回收。
- JRE：Java运行环境，包含JVM和Java类库，以及一些模块。
- JDK： JRE的一个超集，还提供编译器、各类诊断工具。
- Java是大部分解释执行，但是JIT即时编译技术，热点代码提前编译成机器码-这属于编译执行。


**很多点**
- 语言特性：泛型、Lamabda等
- 基础类库：
  - 集合
  - IO/NIO、网络、utils
  - 并发、安全
- JVM
  - 类加载机制、常用JDK版本特点区别
  - 垃圾回收基本原理，常见垃圾收集器：SerialGC、Parallel GC、CMS、G1
  - 工具：编译器、运行时环境、安全工具、诊断、监控工具。
    - 辅助工具，如jlink、jar、jdeps
    - 编译器，javac、sjavac
    - 诊断工具：jmap、jstack、jconsole、jhsdb、jcmd
  - 解释和编译混合（mixed）： 
    - C1对应client模式（适用于启动速度敏感的应用，比如普通Java桌面应用）
    - C2对应server模式（适用于长时间运行的服务端应用）



## 多态&父子类
protected 需要从以下两个点来分析说明：

子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；

子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。

protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。


## 理解 Java 的字符串，String、StringBuffer、StringBuilder 有什 么区别?
**String**
- 它是典型的 Immutable 类，被声明成为 final class，所有属性也都是 final 的。
- 由于它的不可变性，类似拼接、裁剪字符串等动作，都会产生新的 String 对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响


**StringBuffer**：为解决上面提到拼接产生太多中间对象的问题而提供的一个类，我们可以用 append 或者 add 方法，把字符串添加到已有序列的末尾或者指定位置。
- 本质是一个**线程安全**的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销。
- 通过把各种修改数据的方法都加上`Syncronized`关键字实现的。


**StringBuilder** 是 Java 1.5 中新增的，在能力上和 StringBuffer 没有本质区别，但是它去 掉了线程安全的部分，有效减小了开销。字符串拼接优先选它。


**考点**：
* 通过 String 和相关类，考察基本的线程安全设计与实现，各种基础编程实践。 考察 JVM 对象缓存机制的理解以及如何良好地使用。
* 考察 JVM 优化 Java 代码的一些技巧。
* String 相关类的演进，比如 Java 9 中实现的巨大变化。


1. **字符串设计和实现考量**
   1. 因为是不可变的，所以String本身是线程安全的，拷贝函数也不需要额外复制数据。 
   2. StringBuffer 和 StringBuilder 底层都是利用可修改的 (char，JDK 9 以后是 byte)**数组**，二者都继承了 AbstractStringBuilder，里面包含了基 本操作，区别仅在于最终的方法是否加了 synchronize。
   3. 这个内部数组初始字符串长度为+16（如果没有构建对象时输入最初的字符串，那么初始值就是 16）。确定这个长度不够的话，建议给个初始值。扩容会产生多重开销，因为要抛弃原有数组，创建新的(可以简单认为是倍数)数组， 还要进行 arraycopy
   4. 非静态的拼接逻辑在 JDK 8 中会自动被 javac 转换为 StringBuilder 操作。其实就是下面这种： `String str = "aa" + "bb" + "cc" + "dd" ;`会被优化成StringBuilder。
   >在日常编程中，保证程序的可读性、可维护性，往往比所谓的最优性能更重要。
   >String myStr = "aa" +"bb" + "cc" +"dd";反编译后并不会用到StringBuilder，老师反编 译结果中出现StringBuilder是因为输出中拼接了字符串System.out.println("My String:" + myStr);


2. **字符串缓存**
   - 经过粗略统计，将常见应用进行Dump Heap后进行对象组成分析，发现平均25%的对象是字符串，并且其中50%都是重复的。 **如何避免创建重复字符串，可以有效降低内存消耗和对象创建开销**。
   - String 在 Java 6 以后提供了**intern()**方法，目的是提示 JVM 把相应字符串缓存起来，以备重复使用。但真实情况是Java6版本是不推荐这么用的！如果使用不当，会导致OOM。 
    >被缓存的字符串是存在所谓 PermGen 里的，也就是臭名昭著的“永久代”，这个空间是很有限的，也基本不会被 FullGC 之外的垃圾收集照顾到. 后续版本把这个缓存放在了堆中，而Java 8用元空间代替了。
    - Intern 是一种**显式地排重机制**，需要开发者写代码时明确调用，一是不方便，每一个都显式调用是非常麻烦的，另外也无法确定字符串重复情况，效率优化效果不稳定。
    - 在java8后续版本中是支持JVM自动优化， G1 GC 下的字符串排重。 它是通过将相同数据的字符串指向同一份数据来做到的。 默认是关闭的， XX:+UseStringDeduplication，需要指定为G1 GC


3. String自身的演化。
   1. 在 Java 9 中，我们引入了 Compact Strings 的设计，对字符串进行了大刀阔斧的改进。 将数据存储方式从 char 数组，改变为一个 byte 数组加上一个标识编码的所谓 coder，并 且将相关字符串操作类都进行了修改。
   2. 好处： 更小的内存占用，更快的操作速度
   3. 坏处： 由于一个byte数组只有之前char数组的一半，字符串最大长度自然也少了一般，但一般用不到这么长。


**getBytes()等方法最好是指定编码：**，
- 如果不指定则看看JVM 参数里有没有指定file.encoding参数，
- 如果JVM没有指定，那使用的默认编码就是运行的 操作系统环境的编码了，
- 那这个编码就变得不确定了。常见的编码iso8859-1是单字节编 码，UTF-8是变长的编码。

**String s = new String(“abc”) 创建了几个对象?**


String是immutable，在security, Cache，Thread Safe等方面都有很好的体现。 
- Security: 传参的时候我们很多地方使用String参数，可以保证参数不会被改变，比如数据 库连接参数url等，从而保证数据库连接安全。
- Cache: 因为创建String前先去Constant Pool里面查看是否已经存在此字符串，如果已经 存在，就把该字符串的地址引用赋给字符变量;如果没有，则在Constant Pool创建字符


1.通过字面量赋值创建字符串(如:String str=”twm”)时，会先在常量池中查找是否 存在相同的字符串，若存在，则将栈中的引用直接指向该字符串;若不存在，则在常量池 中生成一个字符串，再将栈中的引用指向该字符串。
2.JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常 量池中的引用，这一点与1.7之前没有区别，区别在于，如果在常量池找不到对应的字符



## transient修饰符
transient是短暂的意思。对于transient 修饰的成员变量，在类的实例对象的序列化处理过程中会被忽略。 

因此，transient变量不会贯穿对象的序列化和反序列化，生命周期仅存于调用者的内存中而不会写到磁盘里进行持久化。

比如银行卡密码