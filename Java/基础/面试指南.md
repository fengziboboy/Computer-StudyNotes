
# 面试指南

# 常见面试题

1. Java的第一印象、特点、区别于其他语言的？ 见[《Java基础大杂烩》](./Java基础大杂烩.md)
2. 异常：Error、Exception、Throwable？见[《异常处理》](./异常处理.md)
3. 谈谈 final、finally、 finalize 有什么不同?
    - final：是可以用来修饰类、方法、变量。明确语义和意图，不可修改，也保证安全。减少同步开销，省去一些防御性拷贝的必要。
      - 类： 不可继承扩展
        - 在java.lang 包下面的很多类，相当 一部分都被声明成为 final class?在第三方类库的一些基础类中同样如此，这可以有效避免 API 使用者更改基础功能
      - 变量： 不可修改。 
        - final 字段对性能的影 响，大部分情况下，并没有考虑的必要。
        - final 不是 immutable!：
      - 方法： 不可重写（override）
    - finally：是Java 保证重点代码一定要被执行的一种机制。
      - 经常用在try-catch-finally中类似JDBC关闭连接、保证unlock锁等动作，不过关闭资源推荐使用try-with-resources语句。
    - finalize： 是基础类java.lang.Object的一个方法，设计目的是保证对象在被垃圾收集前完成特定资源的回收。（不在推荐使用）
      - 不推荐原因：你无法保证 finalize 什么时候执行，执行的是否符合预期。使用不当会 影响性能，导致程序死锁、挂起等。
    >面试官还可以考察你对性能、并发、对象生命周期或垃圾 收集基本过程等方面的理解.


4. 强引用、软引用、弱引用、幻象引用有什么区别?


# 集合

## ArrayList、Vector、LinkedList有何区别？

- Vector 是 Java 早期提供的**线程安全**的动态数组，如果不需要线程安全，并不建议选择， 毕竟同步是有额外开销的。扩容会创建新的数组，并拷贝原来的数组数据。 扩容1倍。 
- ArrayList 是应用更加广泛的动态数组实现，它本身不是线程安全的，所以性能要好很多。扩容50%。
- LinkedList 是双向链表，不需要调整容量，**不是线程安全**。


如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。

* **TreeSet** 支持自然顺序访问，但是添加、删除、包含等操作要相对低效(log(n) 时 间)。
* **HashSet** 则是利用哈希算法，理想情况下，如果哈希散列正常，可以提供常数时间的添 加、删除、包含等操作，但是它不保证有序。
* **LinkedHashSet**，内部构建了一个记录插入顺序的双向链表，因此提供了按照插入顺序 遍历的能力，与此同时，也保证了常数时间的添加、删除、包含等操作，这些操作性能略 低于 HashSet，因为需要维护链表的开销。
  * 在遍历元素时，HashSet 性能受自身容量影响，所以初始化时，除非有必要，不然不要 将其背后的 HashMap 容量设置过大。
  * 而对于 LinkedHashSet，由于其内部链表提供的 方便，遍历性能只和元素多少有关系。


**集合排序**

 Java 提供的默认排序算法，具体是什么排序方 式以及设计思路等。

这个问题本身就是有点陷阱的意味，因为需要区分是 Arrays.sort() 还是 Collections.sort() (底层是调用 Arrays.sort());什么数据类型;多大的数据集(太小的数据集，复杂排序 是没必要的，Java 会直接进行二分插入排序)等。
对于原始数据类型，目前使用的是所谓双轴快速排序(Dual-Pivot QuickSort)，是一 种改进的快速排序算法，早期版本是相对传统的快速排序，你可以阅读源码。


而对于对象数据类型，目前则是使用TimSort，思想上也是一种归并和二分插入排序 (binarySort)结合的优化排序算法。TimSort 并不是 Java 的独创，简单说它的思路是 查找数据集中已经排好序的分区(这里叫 run)，然后合并这些分区来达到排序的目的。


另外，Java 8 引入了并行排序算法(直接使用 parallelSort 方法)，这是为了充分利用现 代多核处理器的计算能力，底层实现基于 fork-join 框架(专栏后面会对 fork-join 进行相 对详细的介绍)，当处理的数据集比较小的时候，差距不明显，甚至还表现差一点;但是， 当数据集增长到数万或百万以上时，提高就非常大了，具体还是取决于处理器和系统环境。


##  Hashtable、HashMap、TreeMap 有什么不同?

- Hashtable： 同步，不支持null键和值。
- HashMap： 不同步，支持 null 键和值。 存取时间接近常数。
- TreeMap 则是基于红黑树的一种提供**顺序**访问的 Map，它的 get、 put、remove 之类操作都是 O(log(n))的时间复杂度 


**Map**

**继承关系**
- Dictionary：HashTable：Properties
- AbstractMap： HashMap：LinkedHashMap、TreeMap、EnumMap
- EnumMap、HashMap、SortedMap


HashMap 的性能表现非常依赖于哈希码的有 效性，请务必掌握 **hashCode 和 equals **的一些基本约定，比如:

- equals 相等，hashCode 一定要相等。
- 重写了 hashCode 也要重写 equals。
- hashCode 需要保持一致性，状态改变返回的哈希值仍然要一致。
- equals 的对称、反射、传递等特性。


LinkedHashMap 和 TreeMap 都可以保证某种**顺序**，但二者还是非常不同的。

- LinkedHashMap 通常提供的是**遍历顺序符合插入顺序**，它的实现是通过为条目(键值 对)维护一个双向链表。注意，通过特定构造函数，我们可以创建反映访问顺序的实例， 所谓的 put、get、compute 等，都算作“访问”。 **插入顺序就是遍历读取的顺序？ get操作也算是访问，如果get过会被放在前面**
  - 用处：我们构建一个空间占用敏感的资源池，希望可以自动将最不常被访问的对象释放掉，这就可以利用 LinkedHashMap 提供的机制来实现。
  - 构建一个具有优先级的调度系统的问题，其本质就是个 典型的优先队列场景，Java 标准库提供了基于二叉堆实现的 PriorityQueue，它们都是依 赖于**同一种排序机制**，当然也包括 TreeMap 的马甲 TreeSet。


### **HashMap 源码分析**

**HashMap 内部实现基本点分析**

1. HashMap内部结构可以看作是数组(Node<K,V>[] table)和链表结合组成的复合结构，数组被分为一个个桶(bucket)，通过哈希值决定了 键值对在这个数组的寻址;
2. 哈希值相同的键值对，以链表形式存储，链表大小超过（8），就会被改造为树形结构。


**容量(capacity)和负载系数(load factor)**
  

**树化**