# 《设计模式之美》

# 为什么学习设计模式

1. 应对面试中的设计模式相关问题
2. 告别写被人吐槽的烂代码
   1. 我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！
   2. 每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出
3. 提高复杂代码的设计和开发能力
   1. 只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。
   2. 如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？
4. 让读源码、学框架事半功倍
   1. 优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路
   2. 还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。
5. 为你的职场发展做铺垫

# 好代码

## 评判好坏标准

**评价词**：灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……

**常用评价标准**：
1. **可维护性（maintainability）**
   1. 如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。
   2. 相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。
   >代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

2. **可读性（readability）**
   1. 是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合
   2. code review时同事看得轻松就是可读性好。
3.  **可扩展性（extensibility）**
    1.  方便加新功能。
4.  灵活性（flexibility）
   1.  当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。
   2.  当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。
   3.  当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。 
5. 简洁性（simplicity）
   1. 符合 KISS 原则
   2. 思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。
6. 可复用性
   1. 代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的
   2. 当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。
7. 可测试性（testability）

## 面向对象、设计原则、设计模式、编程规范、重构

- [ ] 很多人用面向对象语言，写面向过程的代码

### 面向对象 VS 面向过程
问题：
- 什么是面向过程编程与面向过程编程语言？
- 面向对象编程相比面向过程编程有哪些优势？
- 为什么说面向对象编程语言比面向过程编程语言更高级？
- 有哪些看似是面向对象实际是面向过程风格的代码？
- 在面向对象编程中，为什么容易写出面向过程风格的代码？
- 面向过程编程和面向过程编程语言就真的无用武之地了吗？

**概念**：
- 面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为代码设计和实现的基石 。
- 面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。
- 面向过程编程也是一种编程范式或编程风格。它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以**数据**（可以理解为成员变量、属性）**与方法相分离为最主要的特点**。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

**区别**：
- 代码的组织方式不同。
  - 面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。
  - 面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中

**OOP的优势**：
1. OOP 更加能够应对大规模复杂程序的开发
   1. 在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。
   2. 这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。
   3. 利用面向过程的编程语言照样可以写出面向对象风格的代码，只不过可能会比用面向对象编程语言来写面向对象风格的代码，付出的代价要高一些。
2. OOP 风格的代码更易复用、易扩展、易维护
   1. 而面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。
3. OOP 语言更加人性化、更加高级、更加智能
   1. **编程语言越来越人性化**，让人跟机器打交道越来越容易。笼统点讲，就是编程语言越来越高级。
   2. 在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这**让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道**。可以这么说，越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”。
   3. 如果一种新的突破性的编程语言出现，那它肯定是**更加“智能”**的。大胆想象一下，使用这种编程语言，我们可以无需对计算机知识有任何了解，无需像现在这样一行一行地敲很多代码，**只需要把需求文档写清楚，就能自动生成我们想要的软件了**。
      >但其实，进行面向对象编程的时候，很容易不由自主地就写出面向过程风格的代码，或者说感觉面向过程风格的代码更容易写。这是为什么呢？
      你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。**面向过程编程风格恰恰符合人的这种流程化思维方式**。
      - 而面向对象编程风格正好相反。它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。
      - 这样的思考路径比较适合复杂程序的开发，但并不是特别符合人类的思考习惯。
   
   **让人迷惑，到底是面向对象更符合人的思维习惯，还是面向过程更符合？**


**哪些代码设计看似是面向对象，实际是面向过程**
1. 滥用getter、setter方法
   1. 它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格
   2. 在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器（比如例子中的 List 容器），也要防范集合内部数据被修改的危险。
2. 滥用全局变量和全局方法
   1. 问题
      1. 常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。单例类对象在全局代码中只有一份，所以，它相当于一个全局变量。
      2. 静态成员变量归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。
      3. 而常量是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。
      4. 静态方法一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。
      5. 静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格。
   2. 常量类，如果只在自己类用到，可以定义到类里面。 如果其他可能用，也要做下区分MysqlConstants、RedisConfig，不要放在一个大的CommonConstants  ，因为会有几个问题：
      1. 这样的设计会影响代码的可维护性。
      2. 这样的设计还会增加代码的编译时间。
      3. 这样的设计还会影响代码的复用性。
   3. Utils类
      1. **解决什么问题**：从业务含义上，A 类和 B 类并不一定具有继承关系，比如 Crawler 类和 PageAnalyzer 类，它们都用到了 URL 拼接和分割的功能，但并不具有继承关系（既不是父子关系，也不是兄弟关系）。仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。如果不熟悉背后设计思路的同事，发现 Crawler 类和 PageAnalyzer 类继承同一个父类，而父类中定义的却是 URL 相关的操作，会觉得这个代码写得莫名其妙，理解不了。
      2. 然后呢？ 只包含静态方法不包含任何属性的 Utils 类，是**彻彻底底的面向过程的编程风格**。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，要尽量避免滥用，不要不加思考地随意去定义 Utils 类。
      3. 思考：
         1. 你真的需要单独定义这样一个 Utils 类吗？是否可以把 Utils 类中的某些方法定义到其他类中呢？
         2. FileUtils、IOUtils、StringUtils、UrlUtils不同用不同
3. **定义数据和方法分离的类**
   1. 一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。
   2. 实际上，这种开发模式叫作**基于贫血模型**的开发模式，也是我们现在非常常用的一种 Web 项目的开发模式