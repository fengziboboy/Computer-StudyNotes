# 网络那点事
[TOC]

# TCP/IP协议

其实不管哪一层的协议，协议包含的报头信息一般都有： 
- 源地址，目标地址，TCP是端口号。我要知道地方才能传输呀；
- 上一层用的的协议，肯定得懂规矩。 
- 数据：什么本层报头，上一层报头，上一层数据....； 
- 对了，当初因为传输不靠谱，一般都有个校验值。

IP协议：
    - TTL 数据报的生存时间，可经过的最多路由器总数。没经过一个路由器，该值减1，为0就丢弃该报文，并发送 **ICMP**报文通知源主机，防止其一直发送报文。
        >ICMP是检测传输网络是否通畅、主机是否可达、路由是否可用等网 络运行状态的协议。  
        >虽然并不传输用户数据，但是对评估网络健康状态非常重 要，经常使用的 ping、 tracert 命令就是基于 ICMP 检测网络状态的有力工具。


## 三次握手
- 信息对等
  > 第三次握手后：B机器才能确认自己的发报能力和对方的收报能力
- 防止超时
  > **这些都是源于报文可能丢失！！！或者迷路慢了。** TTL网络报文的生存时间 > TCP请求超时时间 ==> 两次握手建立连接的话，第一次连接请求慢到了，但是第二次重试连接成功，而且通信结束，顺便关闭连接了，（此时A已经不是SYN_SENT，不会接收请求）这第一次迷路的连接请求才到，B机器就以为A要跟他建立新连接，跟A发确认数据，A会直接丢掉，B就苦苦等待，也就是出现脏连接。

## 四次挥手
1. A FIN=1，告诉B我准备分手了。 A现在是待分手（半关闭状态 FIN_WAIT_1）
2. B ACK=1 , 告诉B 分手就分手，谁怕谁！就是有点突然，等我准备一下（处理完数据）。B现在是待分手（半关闭状态 CLOSE_WAIT）A收到ACK进入FIN_WAIT_2（如果B这渣男不需要准备，直接发ACK、FIN），A可以直接跳过这个状态进入3中的TIME_WAIT
3. B FIN=1、ACK=1，主动告诉B，我做好准备了，随手可以分手。B现在是LAST_ACK
4. A ACK=1，确定了对方也做好分手的准备了，最后一次告诉你，分手吧不用回。 A现在是TIME_WAIT（顾名思义等某个时间），等两个月（2MSL），还没收到B的挽回消息，那就能确定，B收到了A最后的分手通牒。 **正式分手成功！！**

- 这个MSL其实挺长的，在当前告诉网络，这是非常耗时的，在高并发等服务器上这是浪费资源。但是为什么还非要等呢？
    1. 确认被动关闭放能顺利进入CLOSED状态，B表示 我被分手但是不甘心，没收到你的最后通牒我是不会死心的。 如果你不给我时间，我可能就会一直拖着。
    2. 防止失效请求。
- TIME_WAIT状态下是无法释放句柄资源的，高并发服务器上会极大限制有效连接的数量，成为性能瓶颈。所以， **建议将高并发服务器的TIME_WAIT超时时间调小**。 （小于30秒为宜），怎么改？ `/etc/sysctl.conf`，修改值