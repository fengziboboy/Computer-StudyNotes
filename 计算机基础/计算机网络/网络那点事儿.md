# 网络那点事
[TOC]

# TCP/IP协议

## TCP介绍

其实不管哪一层的协议，协议包含的报头信息一般都有： 
- 源地址，目标地址，TCP是端口号。我要知道地方才能传输呀；
- 上一层用的的协议，肯定得懂规矩。 
- 数据：什么本层报头，上一层报头，上一层数据....； 
- 对了，当初因为传输不靠谱，一般都有个校验值。

IP协议：
    - TTL 数据报的生存时间，可经过的最多路由器总数。没经过一个路由器，该值减1，为0就丢弃该报文，并发送 **ICMP**报文通知源主机，防止其一直发送报文。
        >ICMP是检测传输网络是否通畅、主机是否可达、路由是否可用等网 络运行状态的协议。  
        >虽然并不传输用户数据，但是对评估网络健康状态非常重 要，经常使用的 ping、 tracert 命令就是基于 ICMP 检测网络状态的有力工具。

### TCP与UDP
传输层： TCP可靠，UDP不可靠
- TCP使用：`fd = socket(AF_INET,SOCK_STREAM,0);`
  - 其中SOCK_STREAM，是指使用字节流传输数据，就是TCP协议。这也是TCP基于字节流的题中之义，UDP是面向数据包。TCP还有两个特点：可靠、面向连接
  - 在定义了socket之后，我们就可以愉快的对这个socket进行操作，比如用bind()绑定IP端口，用connect()发起建连。之后就可以recv()和send（）接发数据了


#### TCP基于字节流

- 字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。
- 纯裸TCP收发的这些 01 串之间是**没有任何边界**的，你根本不知道到哪个地方才算一条完整消息，这就是所谓的**粘包问题**。
- **所以需要约定个规则去区分这些01串的边界、含义**——这就是上层协议，于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC（这些是定义了不同消息格式的应用层协议）。
  - 比如约定消息头，消息头里写清楚一个完整的包长度是多少、消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的**协议**。


#### 既然有HTTP协议，为什么还要有RPC

[摘录自小白debug](https://mp.weixin.qq.com/s?__biz=MjM5NTY1MjY0MQ==&mid=2650859827&idx=3&sn=3baa2cdddab891cf90907dabb1985b77&chksm=bd017c7d8a76f56b7cdeed529c44363b7f65de1ad49785fb52aa1c746c0314e4d78282464e2a&scene=27)


**HTTP**

HTTP协议（Hyper Text Transfer Protocol），又叫做超文本传输协议。


**RPC**

RPC（Remote Procedure Call），又叫做远程过程调用。它本身并不是一个具体的协议，而是一种调用方式。

- 想像调用本地方法一样调用远程的方法，屏蔽掉一些网络细节，基于这个思路，大佬们造出了非常多款式的RPC协议，比如比较有名的gRPC，thrift。
- 虽然大部分RPC协议底层使用TCP，但实际上它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。gRPC就是用的HTTP2协议，



**TCP是70年代出来**的协议，而**HTTP是90年代**才开始流行的。而直接使用裸TCP会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有**80年代出来的RPC**。问题应该反过来

**那既然有RPC了，为什么还要有HTTP呢？**


**1. HTTP和RPC有什么区别**

- **服务发现**： 想要访问某个服务，就去这些中间服务去获得IP和端口信息。 两者区别不大
  - HTTP：就是寻找IP和端口的过程，用到DNS服务。
  - RPC：一般会有专门的中间服务去保存服务名和IP信息，比如consul或者etcd，甚至是redis。
  - 由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如CoreDNS。
- **底层连接形式**：
  - HTTP：以主流的HTTP1.1协议为例，其默认在**建立底层TCP连接**之后会一直保持这个连接（keep alive），之后的请求和响应都会**复用**这条连接。
  - RPC：也是通过**建立TCP长链接**进行数据交互，但不同的地方在于，RPC协议一般还会再建个连接池，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，用完放回去，下次再复用，可以说非常环保。



## 三次握手 & 四次挥手

### 三次握手
- 信息对等
  > 第三次握手后：B机器才能确认自己的发报能力和对方的收报能力
- 防止超时
  > **这些都是源于报文可能丢失！！！或者迷路慢了。** TTL网络报文的生存时间 > TCP请求超时时间 ==> 两次握手建立连接的话，第一次连接请求慢到了，但是第二次重试连接成功，而且通信结束，顺便关闭连接了，（此时A已经不是SYN_SENT，不会接收请求）这第一次迷路的连接请求才到，B机器就以为A要跟他建立新连接，跟A发确认数据，A会直接丢掉，B就苦苦等待，也就是出现脏连接。

### 四次挥手 
1. A FIN=1，告诉B我准备分手了。 A现在是待分手（半关闭状态 FIN_WAIT_1）
2. B ACK=1 , 告诉B 分手就分手，谁怕谁！就是有点突然，等我准备一下（处理完数据）。B现在是待分手（半关闭状态 CLOSE_WAIT）A收到ACK进入FIN_WAIT_2（如果B这渣男不需要准备，直接发ACK、FIN），A可以直接跳过这个状态进入3中的TIME_WAIT
3. B FIN=1、ACK=1，主动告诉B，我做好准备了，随手可以分手。B现在是LAST_ACK
4. A ACK=1，确定了对方也做好分手的准备了，最后一次告诉你，分手吧不用回。 A现在是TIME_WAIT（顾名思义等某个时间），等两个月（2MSL），还没收到B的挽回消息，那就能确定，B收到了A最后的分手通牒。 **正式分手成功！！**

- 这个MSL其实挺长的，在当前告诉网络，这是非常耗时的，在高并发等服务器上这是浪费资源。但是为什么还非要等呢？
    1. 确认被动关闭放能顺利进入CLOSED状态，B表示 我被分手但是不甘心，没收到你的最后通牒我是不会死心的。 如果你不给我时间，我可能就会一直拖着。
    2. 防止失效请求。
- TIME_WAIT状态下是无法释放句柄资源的，高并发服务器上会极大限制有效连接的数量，成为性能瓶颈。所以， **建议将高并发服务器的TIME_WAIT超时时间调小**。 （小于30秒为宜），怎么改？ `/etc/sysctl.conf`，修改值


## HTTP

### 有了HTTP为啥还要RPC


### HTTPS

#### TSL/SSL & 四次挥手

