## 2019-8-5
### map的遍历：
如果只需要map中的键或者值，你可以通过keySet或values来实现遍历，而不是用entrySet。
``` java
Map<Integer, Integer> map = new HashMap<Integer, Integer>();
//遍历map中的键 
for (Integer key : map.keySet()) {
    System.out.println("Key = " + key); 
}
//遍历map中的值
for (Integer value : map.values()) {
    System.out.println("Value = " + value);
}

```
## 2019-8-6
### 自定义一串数字转List，方便测试
`List listA1 = Arrays.asList(1,2,3);`

## 2019-8-8 
### Set初始化
```java
public static final String[] SET_VALUES = new String[] { "a", "b" };
public static final Set<String> MY_SET = new HashSet<String>(Arrays.asList(SET_VALUES));
```

### Json第二版
```json
[
    {
        "image": [
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ],
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ]
        ],
        "price": [
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ],
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ]
        ],
        "title": [
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ],
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ]
        ],
        "url": [
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ],
            [
                {
                    "nameOfChinese": "",
                    "nameOfEnglish": ""
                }
            ]
        ]
    }
]
```

## 8.12 两个Integer对象的值是否相等
不能用 == ，也不能用equal，推荐用Objects.equals(a, b)。

或者 ac.getCourse().getId().compareTo(course.getId()) ==0

### @Autowired 注入失败问题
1. 需要是Bean，比如@component或 @Service 之类的类。
2. 静态static试一试？
3. 将方法修饰符改为public;
4. 使用AspectJ来进行注入。

### 工具类，静态方法，调用就用 类名.方法名()

## 8.13 一些技巧
### 判断字符串是否为数字是否为整数
org.apache.commons.lang3.math库下的包
NumberUtils：
    - isDigits:判断字符串中是否全为数字
    - toInt(String):字符串转换为整数
    - toLong(String, defaultValue):字符串转换为Long数字，失败转成默认值。

## 8.16 抽象类和接口的应用场景
接口：
- A. 类与类之前需要特定的接口进行协调，而不在乎其如何实现。
- B. 作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识。
- C. 需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
- D. 需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

抽象类：
- A. 定义了一组接口，但**又不想强迫每个实现类都必须实现所有的接口**。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
- B. 某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
- C. 规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能
