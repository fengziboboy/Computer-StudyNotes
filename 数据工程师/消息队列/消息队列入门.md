


## 05 | 如何确保消息不会丢失?


### 检测消息丢失的方法

我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 Producer 端， 我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的 连续性。

- 如果检测到序号不连续，那就是丢消息了。还可 以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。


大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 Producer 发 送消息之前的拦截器中将序号注入到消息中,在 Consumer 收到消息的拦截器中检测序号 的连续性。 好处：不会侵入业务代码逻辑，稳定后还能关闭。


**难点**

- 像 `Kafka` 和 `RocketMQ` 这样的消息队列，它是**不保证在 Topic 上的严格顺序**的， 只能**保证分区上的消息是有序的**：
  >所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。

- 如果你的系统中 **Producer 是多实例**的，由于并不好协调多个Producer 之间的发送顺序， 所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识， 在 Consumer 端**按照每个Producer分别来检测序号的连续性**。


- Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。



### 确保消息可靠传递

整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。

- 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 存储阶段: 
- 存储阶段： 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
- 消费阶段： Consumer从Broker上拉取消息，经过网络传输发送到 Consumer 上。



1. **生产阶段**

在生产阶段，消息队列通过最常用的请求确认机制，来保证消息的可靠传递: 客户端发消息到Broker，Broker收到消息后给客户端返回一个确认响应， 客户端收到响应，完成一次正常消息发送。

- 只要 Producer 收到了 Broker 的确认响应，就可以保证消息在生产阶段不会丢失
- 有些消息队列在长时间没收到发送确认响应后，会自动重试，如果重试再失败，就会**以返回值或者 异常的方式**告知用户。 **正确处理返回值或者捕获异常，就可以保证这个阶段的消息不会丢失。**
- 异步发送时，则需要在回调方法里进行检查。这个地方是需要特别注意的，**很多丢消息的原
因**就是，我们使用了异步发送，却**没有在回调中检查发送结果**。


2. **存储阶段**

正常运行就不会丢消息，但如果 Broker 出现了故障，比如进程死掉了或者服务器宕机了，还是可能会丢失消息的。

**如果对消息的可靠性要求非常高，可以通过配置 Broker 参数来避免因为宕机丢消息。**

- 对于单个节点的 Broker，需要配置 Broker 参数，在收到消息后，将消息**写入磁盘后再给Producer返回确认响应**。
  >例如，在 RocketMQ 中，需要将刷盘方式 flushDiskType 配
置为 SYNC_FLUSH 同步刷盘。

- 如果是 Broker 是由多个节点组成的集群，需要将 Broker 集群配置成: 至少将消息发送到
2 个以上的节点，再给客户端回复发送确认响应。这样当某个 Broker 宕机时，其他的Broker 可以替代宕机的 Broker，也不会发生消息丢失。


3. **消费阶段**

类似生产阶段，通过确认机制保证消息的可靠传递， 消费客户端从Broker拉取消息后，执行用户业务逻辑成功后，才会给Broker发送消费确认消息。  

- 如果Broker长时间内没收到响应，下次拉消息的时候再次返回同一条消息，确保不在网络传输过程中丢失。

- 不要在收到消息后就立即发送消费确认，而是应该在执完所有消费业务逻辑之后，再发送消费确认。


## 06 | 如何处理消费过程中的重复消息?

**消息重复的情况必然存在**

在 MQTT 协议中，给出了三种**传递消息时**能够提供的**服务质量标准**，这三种服务质量从低 到高依次是:

- A**t most once**: 至多一次。消息在传递时，最多会被送达一次。换一个说法就是，没什么消息可靠性保证，**允许丢消息**。一般都是一些**对消息可靠性要求不太高的监控场景**使用，比如每分钟上报一次机房温度数据，可以接受数据少量丢失。


- **At least once**: 至少一次。消息在传递时，至少会被送达一次。也就是说，不允许丢消 息，但是**允许有少量重复消息**出现。


- Exactly once:恰好一次。消息在传递时，只会被送达一次，不允许丢失也不允许重复，这个是**最高的等级。**

>在 Kafka 中，事务和 Excactly once 主要是为了配合流计算使用的特性，Kafka 支持的“Exactly once”和我们刚刚提到的消息传递的服务质量标准“Exactly once”是不一样的.