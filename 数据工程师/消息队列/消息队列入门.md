


## 05 | 如何确保消息不会丢失?


### 检测消息丢失的方法

我们可以利用消息队列的有序性来验证是否有消息丢失。原理非常简单，在 Producer 端， 我们给每个发出的消息附加一个连续递增的序号，然后在 Consumer 端来检查这个序号的 连续性。

- 如果检测到序号不连续，那就是丢消息了。还可 以通过缺失的序号来确定丢失的是哪条消息，方便进一步排查原因。


大多数消息队列的客户端都支持拦截器机制，你可以利用这个拦截器机制，在 Producer 发 送消息之前的拦截器中将序号注入到消息中,在 Consumer 收到消息的拦截器中检测序号 的连续性。 好处：不会侵入业务代码逻辑，稳定后还能关闭。


**难点**

- 像 `Kafka` 和 `RocketMQ` 这样的消息队列，它是**不保证在 Topic 上的严格顺序**的， 只能**保证分区上的消息是有序的**：
  >所以我们在发消息的时候必须要指定分区，并且，在每个分区单独检测消息序号的连续性。

- 如果你的系统中 **Producer 是多实例**的，由于并不好协调多个Producer 之间的发送顺序， 所以也需要每个 Producer 分别生成各自的消息序号，并且需要附加上 Producer 的标识， 在 Consumer 端**按照每个Producer分别来检测序号的连续性**。


- Consumer 实例的数量最好和分区数量一致，做到 Consumer 和分区一一对应，这样会比较方便地在 Consumer 内检测消息序号的连续性。



### 确保消息可靠传递

整个消息从生产到消费的过程中，哪些地方可能会导致丢消息，以及应该如何避免消息丢失。

- 生产阶段: 在这个阶段，从消息在 Producer 创建出来，经过网络传输发送到 Broker 存储阶段: 
- 存储阶段： 在这个阶段，消息在 Broker 端存储，如果是集群，消息会在这个阶段被复制到其他的副本上。
- 消费阶段： Consumer从Broker上拉取消息，经过网络传输发送到 Consumer 上。
